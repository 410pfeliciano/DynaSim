<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ParseModelEquations</title>
  <meta name="keywords" content="ParseModelEquations">
  <meta name="description" content="% model = ParseModelEquations(STRING,'param',value,...)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>ParseModelEquations
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>% model = ParseModelEquations(STRING,'param',value,...)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [model,name_map] = ParseModelEquations(text,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">% model = ParseModelEquations(STRING,'param',value,...)
 Purpose: parse equations and organize model data in DynaSim model structure
 Inputs: 
   STRING (required): one of --
   - string with equations
   - string with name of file containing equations (.eqns or .mech)
   options (using key/value pairs: 'option1',value1,...):
   - 'namespace': (default: '') added as prefix to beginning of parameter/etc names
   - 'delimiter': (default: ';') separates expressions on same line of model text
   user-supplied parameter values: ('key',value): name (key) of parameters to be set and associated user-supplied values
 Outputs:
   model: DynaSim model structure (see CheckModel for details)
   name_map: {name, namespace_name, namespace, type}, useful for namespace-specific substitutions across multiple sub-models
             (see description in GenerateModel for more information)
 
 NOTE 1: .eqns files contain fully self contained model equations; 
 .mech files define (sub)models that depend on variables linked from 
 elsewhere. However, this function does not distinguish between the two.
 
 Examples:
 model = ParseModelEquations('dx/dt=3*a*x; x(0)=0','a',0);
 model = ParseModelEquations('dx/dt=3*a*x, x(0)=0','a',0,'delimiter',',');
 model = ParseModelEquations('CalciumPump.mech','namespace','HH');
 model = ParseModelEquations('LIFneuron.eqns');
 model = ParseModelEquations('a=2; b=2*a; f(x)=b; dx/dt=f(x); x(0)=0; if(x&gt;1)(x=0); current-&gt;f(x); monitor f(x); % comments')
 
 parsing individual sub-models from specification:
 equations=specification.populations(1).equations;
 [model,map] = ParseModelEquations(equations,'namespace','pop')
 population_mechanism=specification.populations(1).mechanism_list{1};
 [model,map] = ParseModelEquations(population_mechanism,'namespace','pop_mech')
 connection_mechanism=specification.connections(1).mechanism_list{1};
 [model,map] = ParseModelEquations(connection_mechanism,'namespace','pop_pop_mech')
 
 See also: <a href="ClassifyEquation.html" class="code" title="function classes=ClassifyEquation(string,delimiter)">ClassifyEquation</a>, <a href="GenerateModel.html" class="code" title="function [model,name_map]=GenerateModel(specification,varargin)">GenerateModel</a>, <a href="LocateModelFiles.html" class="code" title="function [paths,files]=LocateModelFiles(input)">LocateModelFiles</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ClassifyEquation.html" class="code" title="function classes=ClassifyEquation(string,delimiter)">ClassifyEquation</a>	% CLASS=ClassifyEquation(STRING,DELIMITER)</li><li><a href="LocateModelFiles.html" class="code" title="function [paths,files]=LocateModelFiles(input)">LocateModelFiles</a>	% [paths,files]=LocateModelFiles(input)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="CheckSpecification.html" class="code" title="function spec=CheckSpecification(specification)">CheckSpecification</a>	CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</li><li><a href="ImportModel.html" class="code" title="function [model,map] = ImportModel(source,varargin)">ImportModel</a>	[model,map] = ImportModel(source,'option',value,...)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [line,comment]=remove_comment(line)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,name_map] = ParseModelEquations(text,varargin)</a>
0002 <span class="comment">%% model = ParseModelEquations(STRING,'param',value,...)</span>
0003 <span class="comment">% Purpose: parse equations and organize model data in DynaSim model structure</span>
0004 <span class="comment">% Inputs:</span>
0005 <span class="comment">%   STRING (required): one of --</span>
0006 <span class="comment">%   - string with equations</span>
0007 <span class="comment">%   - string with name of file containing equations (.eqns or .mech)</span>
0008 <span class="comment">%   options (using key/value pairs: 'option1',value1,...):</span>
0009 <span class="comment">%   - 'namespace': (default: '') added as prefix to beginning of parameter/etc names</span>
0010 <span class="comment">%   - 'delimiter': (default: ';') separates expressions on same line of model text</span>
0011 <span class="comment">%   user-supplied parameter values: ('key',value): name (key) of parameters to be set and associated user-supplied values</span>
0012 <span class="comment">% Outputs:</span>
0013 <span class="comment">%   model: DynaSim model structure (see CheckModel for details)</span>
0014 <span class="comment">%   name_map: {name, namespace_name, namespace, type}, useful for namespace-specific substitutions across multiple sub-models</span>
0015 <span class="comment">%             (see description in GenerateModel for more information)</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% NOTE 1: .eqns files contain fully self contained model equations;</span>
0018 <span class="comment">% .mech files define (sub)models that depend on variables linked from</span>
0019 <span class="comment">% elsewhere. However, this function does not distinguish between the two.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% Examples:</span>
0022 <span class="comment">% model = ParseModelEquations('dx/dt=3*a*x; x(0)=0','a',0);</span>
0023 <span class="comment">% model = ParseModelEquations('dx/dt=3*a*x, x(0)=0','a',0,'delimiter',',');</span>
0024 <span class="comment">% model = ParseModelEquations('CalciumPump.mech','namespace','HH');</span>
0025 <span class="comment">% model = ParseModelEquations('LIFneuron.eqns');</span>
0026 <span class="comment">% model = ParseModelEquations('a=2; b=2*a; f(x)=b; dx/dt=f(x); x(0)=0; if(x&gt;1)(x=0); current-&gt;f(x); monitor f(x); % comments')</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% parsing individual sub-models from specification:</span>
0029 <span class="comment">% equations=specification.populations(1).equations;</span>
0030 <span class="comment">% [model,map] = ParseModelEquations(equations,'namespace','pop')</span>
0031 <span class="comment">% population_mechanism=specification.populations(1).mechanism_list{1};</span>
0032 <span class="comment">% [model,map] = ParseModelEquations(population_mechanism,'namespace','pop_mech')</span>
0033 <span class="comment">% connection_mechanism=specification.connections(1).mechanism_list{1};</span>
0034 <span class="comment">% [model,map] = ParseModelEquations(connection_mechanism,'namespace','pop_pop_mech')</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% See also: ClassifyEquation, GenerateModel, LocateModelFiles</span>
0037 
0038 model=[];
0039 name_map={};
0040 
0041 <span class="comment">% organize optional user-supplied info</span>
0042 <span class="comment">% key/value pairs</span>
0043 <span class="keyword">if</span> nargin&gt;2 <span class="comment">% check for at least text input and one key/value pair</span>
0044   keys=varargin(1:2:end); <span class="comment">% parameters to set</span>
0045   values=varargin(2:2:end); <span class="comment">% values to use</span>
0046 <span class="keyword">else</span>
0047   keys=[];
0048   values=[];
0049 <span class="keyword">end</span>
0050 <span class="comment">% set namespace</span>
0051 <span class="keyword">if</span> ismember(<span class="string">'namespace'</span>,keys) <span class="comment">% check for user-supplied namespace (i.e., namespace)</span>
0052   namespace=values{ismember(keys,<span class="string">'namespace'</span>)}; <span class="comment">% user-supplied namespace</span>
0053   <span class="keyword">if</span> ~isempty(namespace)
0054     namespace=[namespace <span class="string">'_'</span>];
0055   <span class="keyword">else</span>
0056     namespace=<span class="string">''</span>;
0057   <span class="keyword">end</span>
0058 <span class="keyword">else</span>
0059   namespace=<span class="string">''</span>;
0060 <span class="keyword">end</span>
0061 <span class="comment">% set delimiter</span>
0062 <span class="keyword">if</span> ismember(<span class="string">'delimiter'</span>,keys) <span class="comment">% check for user-supplied delimiter</span>
0063   delimiter = values(ismember(keys,<span class="string">'delimiter'</span>)); <span class="comment">% user-supplied delimiter</span>
0064 <span class="keyword">else</span>
0065   delimiter=<span class="string">';'</span>;
0066 <span class="keyword">end</span>
0067 <span class="comment">% error handling for improper input format</span>
0068 <span class="keyword">if</span> ~ischar(namespace)
0069   error(<span class="string">'model &quot;namespace&quot; must be a string.'</span>);
0070 <span class="keyword">end</span>
0071 <span class="keyword">if</span> ~ischar(delimiter)
0072   error(<span class="string">'expression &quot;delimiter&quot; must be a string.'</span>);
0073 <span class="keyword">end</span>
0074 
0075 <span class="comment">%% 1.0 convert text into cell array of strings (one string per line)</span>
0076 <span class="comment">% check for DynaSim extensions if input is single \w+ string</span>
0077 <span class="keyword">if</span> ischar(text) &amp;&amp; ~any(which(text)) &amp;&amp; isempty(regexp(text,<span class="string">'[^\w.]'</span>,<span class="string">'once'</span>)) <span class="comment">% isempty(regexp(text,'[^\w]','once'))</span>
0078 <span class="comment">%if ischar(text) &amp;&amp; ~exist(text,'file') &amp;&amp; isempty(regexp(text,'[^\w.]','once')) % isempty(regexp(text,'[^\w]','once'))</span>
0079   [~,text]=<a href="LocateModelFiles.html" class="code" title="function [paths,files]=LocateModelFiles(input)">LocateModelFiles</a>(text);
0080   <span class="keyword">if</span> iscell(text) &amp;&amp; ~isempty(text)
0081     text=text{1};
0082   <span class="keyword">end</span>
0083 <span class="keyword">end</span>
0084 <span class="comment">% check if input is a filename</span>
0085 <span class="keyword">if</span> ischar(text) &amp;&amp; exist(text,<span class="string">'file'</span>)
0086   [~,name,ext]=fileparts(text);
0087   <span class="keyword">switch</span> ext
0088     <span class="keyword">case</span> <span class="string">'.m'</span>
0089       model=feval(name); <span class="comment">% evaluate model-creating function and return model</span>
0090       <span class="keyword">return</span>;
0091     <span class="keyword">case</span> <span class="string">'.mat'</span> <span class="comment">% todo: uncomment once ImportModel supports loading .mat</span>
0092       <span class="comment">%model=ImportModel(text);</span>
0093       <span class="comment">%return;</span>
0094   <span class="keyword">end</span>
0095   <span class="comment">% load equations from file</span>
0096   [text,res]=readtext(text,<span class="string">'\n'</span>,<span class="string">'%'</span>); <span class="comment">% text: cell array of strings, one element per line in text file</span>
0097   <span class="comment">% remove all lines without text</span>
0098   text=text(res.stringMask);
0099   <span class="comment">% remove leading/trailing white space</span>
0100   text=strtrim(text);
0101   <span class="comment">% end each line with semicolon</span>
0102   <span class="keyword">for</span> i=1:length(text)
0103     <span class="keyword">if</span> ~isequal(text{i}(end),<span class="string">';'</span>)
0104       text{i}(end+1)=<span class="string">';'</span>;
0105     <span class="keyword">end</span>
0106   <span class="keyword">end</span>
0107   <span class="comment">% concatenate into a single string</span>
0108   text=[text{:}]; <span class="comment">% concatenate text from all lines</span>
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">% split string into cell array of lines delimited by semicolon</span>
0112 <span class="keyword">if</span> ischar(text)
0113   <span class="comment">% remove end-line semicolon if present so split lines are free of all ';'</span>
0114   <span class="keyword">if</span> text(end)==<span class="string">';'</span>
0115     text=text(1:end-1);
0116   <span class="keyword">end</span>
0117   <span class="comment">% account for the one exception where ';' does not delimit lines:</span>
0118   <span class="comment">% conditional actions with multiple statements (expr1; expr2)</span>
0119   <span class="comment">% approach: replace ';' by ',' here then reverse the replacement below</span>
0120   <span class="comment">% when storing the action in model.conditionals</span>
0121   pattern=<span class="string">'(if\([^;]+\)\s*\([^;\)]+);([^;]+\))'</span>; <span class="comment">% if(condiiton)(action1;action2)</span>
0122   replace=<span class="string">'$1,$2'</span>;
0123   text=regexprep(text,pattern,replace,<span class="string">'ignorecase'</span>);
0124   <span class="comment">% now split string into cell array of lines</span>
0125   text = strtrim(regexp(text,delimiter,<span class="string">'split'</span>));
0126 <span class="keyword">end</span>
0127 <span class="keyword">if</span> ~iscellstr(text)
0128   error(<span class="string">'input not recognized. equations must be provided in single string, cell array of strings, or a text file'</span>);
0129 <span class="keyword">end</span>
0130 
0131 <span class="comment">%% 2.0 classify and parse lines; store info in model structure</span>
0132 model.parameters=[];
0133 model.fixed_variables=[];
0134 model.functions=[];
0135 model.monitors=[];
0136 model.state_variables={};
0137 model.ODEs=[];
0138 model.ICs=[];
0139 model.conditionals=[];
0140 model.linkers=[];
0141 model.comments={};
0142 <span class="keyword">for</span> index=1:length(text) <span class="comment">% loop over lines of text</span>
0143   <span class="comment">% organize model data in model structure</span>
0144   line=text{index}; <span class="comment">% choose a single expression (lines with multiple expressions have already been split above using regexp-split)</span>
0145   [line,comment]=<a href="#_sub1" class="code" title="subfunction [line,comment]=remove_comment(line)">remove_comment</a>(line); <span class="comment">% remove comments</span>
0146   <span class="keyword">if</span> isempty(line) <span class="comment">% e.g., entire line was a comment, or there was nothing there originally</span>
0147     <span class="keyword">if</span> ~isempty(comment)
0148       model.comments{end+1}=comment;
0149     <span class="keyword">end</span>
0150     <span class="keyword">continue</span>;
0151   <span class="keyword">end</span>
0152   <span class="keyword">switch</span> <a href="ClassifyEquation.html" class="code" title="function classes=ClassifyEquation(string,delimiter)">ClassifyEquation</a>(line,delimiter) <span class="comment">% classify</span>
0153     <span class="keyword">case</span> <span class="string">'parameter'</span>        <span class="comment">% var=(string or number)</span>
0154       rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0155       lhs=regexp(line,<span class="string">'^([\w\.]+)\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0156       lhs{1}=strrep(lhs{1},<span class="string">'.'</span>,<span class="string">'_'</span>); <span class="comment">% e.g., Na.g --&gt; Na_g</span>
0157       name=strtrim(lhs{1}); expression=rhs{1};
0158       model.parameters.([namespace name]) = expression;
0159       name_map(end+1,:) = {name,[namespace name],namespace,<span class="string">'parameters'</span>};
0160       <span class="keyword">if</span> ~isempty(comment)
0161         model.comments{end+1}=sprintf(<span class="string">'%s (parameter): %s'</span>,[namespace name],comment);
0162       <span class="keyword">end</span>
0163     <span class="keyword">case</span> <span class="string">'fixed_variable'</span>   <span class="comment">% var=(expression with grouping or arithmetic), var(#), var([#]), var([# #]), var([#,#]), var(#:#), var(#:end), var([#:#]), var([#:end])</span>
0164       lhs=regexp(line,<span class="string">'^(\w+)\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0165       rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0166       name=strtrim(lhs{1}); expression=rhs{1};
0167       model.fixed_variables.([namespace name]) = expression;
0168       name_map(end+1,:) = {name,[namespace name],namespace,<span class="string">'fixed_variables'</span>};
0169       <span class="keyword">if</span> ~isempty(comment)
0170         model.comments{end+1}=sprintf(<span class="string">'%s (fixed_variable): %s'</span>,[namespace name],comment);
0171       <span class="keyword">end</span>
0172     <span class="keyword">case</span> <span class="string">'function'</span>         <span class="comment">% f(vars)=exression</span>
0173 <span class="comment">%       if any(line=='@')</span>
0174 <span class="comment">%         line=strrep(line,'@','');</span>
0175 <span class="comment">%         %error('model specification error: delete the ''@'' character from all function definitions and try again.');</span>
0176 <span class="comment">%       end</span>
0177       name=regexp(line,<span class="string">'^(.+)\(.*\)\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0178       vars=regexp(line,<span class="string">'\((.+)\)\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);      
0179       rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0180       name=strtrim(name{1}); 
0181       expression=sprintf(<span class="string">'@(%s)%s'</span>,vars{1},rhs{1});
0182       model.functions.([namespace name]) = expression;
0183       name_map(end+1,:) = {name,[namespace name],namespace,<span class="string">'functions'</span>};
0184       <span class="keyword">if</span> ~isempty(comment)
0185         model.comments{end+1}=sprintf(<span class="string">'%s (function): %s'</span>,[namespace name],comment);
0186       <span class="keyword">end</span>
0187     <span class="keyword">case</span> <span class="string">'ODE'</span>              <span class="comment">% x'=expression or dx/dt=expression</span>
0188       var=regexp(line,<span class="string">'^d(\w+)/dt\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% x from dx/dt=</span>
0189       <span class="keyword">if</span> isempty(var)
0190         var=regexp(line,<span class="string">'^(\w+)''\s*='</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% x from x'=</span>
0191       <span class="keyword">end</span>
0192       rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0193       state_variable=strtrim(var{1}); expression=rhs{1};
0194       model.ODEs.([namespace state_variable])=expression;      
0195       <span class="keyword">if</span> ~ismember([namespace state_variable],model.state_variables)
0196         name_map(end+1,:) = {state_variable,[namespace state_variable],namespace,<span class="string">'state_variables'</span>};
0197         model.state_variables{end+1}=[namespace state_variable];
0198       <span class="keyword">end</span>
0199       <span class="keyword">if</span> ~isempty(comment)
0200         model.comments{end+1}=sprintf(<span class="string">'d/dt %s (ODE): %s'</span>,[namespace state_variable],comment);
0201       <span class="keyword">end</span>
0202     <span class="keyword">case</span> <span class="string">'IC'</span>               <span class="comment">% x(0)=expression</span>
0203       var=regexp(line,<span class="string">'^(\w+)\('</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0204       rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0205       state_variable=strtrim(var{1}); expression=rhs{1};
0206       model.ICs.([namespace state_variable])=expression;
0207       <span class="keyword">if</span> ~isempty(comment)
0208         model.comments{end+1}=sprintf(<span class="string">'%s(0) (IC): %s'</span>,[namespace state_variable],comment);
0209       <span class="keyword">end</span>
0210     <span class="keyword">case</span> <span class="string">'monitor'</span>          <span class="comment">% monitor f=(expression or function)</span>
0211       <span class="comment">% split list of monitors</span>
0212       lines=strtrim(regexp(line,<span class="string">','</span>,<span class="string">'split'</span>)); 
0213       <span class="comment">% loop over monitors in list</span>
0214       <span class="keyword">for</span> l=1:length(lines)
0215         <span class="comment">% process this monitor</span>
0216         line=lines{l};
0217         <span class="comment">% split left and right parts of monitor</span>
0218         lhs=regexp(line,<span class="string">'^monitor ([\w,@\s\.]+)'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0219         <span class="keyword">if</span> isempty(lhs)
0220           lhs=regexp(line,<span class="string">'([\w,@\s\.]+)'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0221         <span class="keyword">end</span>        
0222         rhs=regexp(line,<span class="string">'=(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);      
0223         <span class="comment">% expand list of monitor names (e.g., monitor iNa.I, iK.I)</span>
0224         names=strtrim(regexp(lhs{1},<span class="string">','</span>,<span class="string">'split'</span>));
0225         <span class="keyword">for</span> i=1:length(names) <span class="comment">% loop over list of monitors on this line</span>
0226           name=names{i};
0227           <span class="comment">% process special monitors (those including '.', e.g., v.spikes(0))</span>
0228           <span class="comment">% todo: clean up or generalize this procedure...</span>
0229           <span class="keyword">if</span> any(name==<span class="string">'.'</span>)
0230             <span class="comment">% check for numeric monitor argument</span>
0231             arg=regexp(line,[name <span class="string">'\(([-+]*\w+)\)'</span>],<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0232             <span class="comment">%arg=regexp(line,[name '\(([-+]*\d+)\)'],'tokens','once');</span>
0233             <span class="comment">% set argument as expression (see WriteDynaSimSolver() for usage as such)</span>
0234             <span class="keyword">if</span> ~isempty(arg)
0235               rhs=arg;
0236             <span class="keyword">end</span>
0237           <span class="keyword">end</span>
0238           <span class="comment">% convert into valid monitor name</span>
0239           name=strrep(name,<span class="string">'.'</span>,<span class="string">'_'</span>); <span class="comment">% index sub-namespace (monitor Na.I)</span>
0240           <span class="keyword">if</span> ~isempty(rhs), expression=rhs{1}; <span class="keyword">else</span> expression=[]; <span class="keyword">end</span>
0241           model.monitors.([namespace name]) = expression;
0242           name_map(end+1,:) = {name,[namespace name],namespace,<span class="string">'monitors'</span>};
0243           <span class="keyword">if</span> ~isempty(comment)
0244             model.comments{end+1}=sprintf(<span class="string">'%s (monitor): %s'</span>,[namespace name],comment);
0245           <span class="keyword">end</span>
0246         <span class="keyword">end</span>
0247       
0248       <span class="keyword">end</span>
0249       
0250     <span class="keyword">case</span> <span class="string">'conditional'</span>      <span class="comment">% if(conditions)(actions)</span>
0251       groups=regexp(line,<span class="string">')('</span>,<span class="string">'split'</span>);
0252       condition=regexp(groups{1},<span class="string">'^if\s*\((.*)'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0253       <span class="keyword">if</span> length(groups)==2
0254         <span class="keyword">if</span> groups{2}(end)==<span class="string">')'</span>
0255           groups{2}=groups{2}(1:end-1);
0256         <span class="keyword">end</span>
0257         then_action=groups{2};
0258         else_action=[];
0259       <span class="keyword">elseif</span> numel(groups==3)
0260         <span class="keyword">if</span> groups{3}(end)==<span class="string">')'</span>
0261           groups{3}=groups{3}(1:end-1);
0262         <span class="keyword">end</span>
0263         then_action=groups{2};
0264         else_action=groups{3};
0265       <span class="keyword">end</span>
0266       model.conditionals(end+1).namespace=namespace;
0267       model.conditionals(end).condition=condition{1};
0268       model.conditionals(end).action=strrep(then_action,<span class="string">','</span>,<span class="string">';'</span>); <span class="comment">% restore semicolon-delimited multiple actions like if(x&gt;1)(x=0;y=0)</span>
0269       <span class="keyword">if</span> length(groups)&gt;2
0270         model.conditionals(end).else=else_action;
0271       <span class="keyword">else</span>
0272         model.conditionals(end).else=[];
0273       <span class="keyword">end</span>
0274 <span class="comment">%       groups=regexp(line,'\(((\w+\([\w,@]+\))?[\w@-\+*^/\s&gt;&lt;=,&amp;|\.]+)\)','tokens');</span>
0275 <span class="comment">%       condition=groups{1}{1};</span>
0276 <span class="comment">%       model.conditionals(end+1).namespace=namespace;</span>
0277 <span class="comment">%       model.conditionals(end).condition=condition;</span>
0278 <span class="comment">%       model.conditionals(end).action=strrep(groups{2}{1},',',';'); % restore semicolon-delimited multiple actions like if(x&gt;1)(x=0;y=0)</span>
0279 <span class="comment">%       if length(groups)&gt;2</span>
0280 <span class="comment">%         model.conditionals(end).else=groups{3}{1};</span>
0281 <span class="comment">%       else</span>
0282 <span class="comment">%         model.conditionals(end).else=[];</span>
0283 <span class="comment">%       end</span>
0284       <span class="keyword">if</span> ~isempty(comment)
0285         model.comments{end+1}=sprintf(<span class="string">'%s conditional(%s): %s'</span>,namespace,condition,comment);
0286       <span class="keyword">end</span>
0287     <span class="keyword">case</span> <span class="string">'linker'</span>           <span class="comment">% [link ]? target operation expression (e.g., link target += f(x))</span>
0288       <span class="comment">% viable options: ((\+=)|(-=)|(\*=)|(/=)|(=&gt;))</span>
0289       line=regexprep(line,<span class="string">'^link (\s*\w)'</span>,<span class="string">'$1'</span>);
0290       lhs=regexp(line,<span class="string">'^([^\+\-*/=]+)'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); <span class="comment">% +=</span>
0291       rhs=regexp(line,<span class="string">'=&gt;?(.+)$'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0292       model.linkers(end+1).namespace=namespace;
0293       <span class="keyword">if</span> ~isempty(lhs), target=strtrim(lhs{1}); <span class="keyword">else</span> target=[]; <span class="keyword">end</span>
0294       <span class="keyword">if</span> ~isempty(rhs), expression=strtrim(rhs{1}); <span class="keyword">else</span> expression=[]; <span class="keyword">end</span>
0295       <span class="keyword">if</span> expression(end)==<span class="string">';'</span>, expression=expression(1:end-1); <span class="keyword">end</span>
0296       <span class="keyword">if</span> isempty(target), target=expression; <span class="keyword">end</span> <span class="comment">% for sharing state var across mechanisms in same population</span>
0297       <span class="keyword">if</span> isempty(expression), expression=target; <span class="keyword">end</span>
0298       model.linkers(end).target=target;
0299       model.linkers(end).expression=expression;
0300       model.linkers(end).operation=<span class="string">'+='</span>;
0301       <span class="keyword">if</span> ~isempty(comment)
0302         model.comments{end+1}=sprintf(<span class="string">'%s linkers(%s-&gt;%s): %s'</span>,namespace,target,expression,comment);
0303       <span class="keyword">end</span>
0304       <span class="keyword">if</span> ~isempty(comment)
0305         model.linkers(end).comment=comment;
0306       <span class="keyword">end</span>
0307     <span class="keyword">otherwise</span>
0308       warning(<span class="string">'ignoring line, failed to classify :%s'</span>,line);
0309   <span class="keyword">end</span>
0310 <span class="keyword">end</span>
0311 
0312 
0313 <span class="comment">% subfunctions</span>
0314 <a name="_sub1" href="#_subfunctions" class="code">function [line,comment]=remove_comment(line)</a>
0315 <span class="comment">% purpose: split line into model content and comment</span>
0316 index=find(line==<span class="string">'%'</span>,1,<span class="string">'first'</span>);
0317 <span class="keyword">if</span> isempty(index) 
0318   <span class="comment">% check other valid comment delimiters</span>
0319   index=find(line==<span class="string">'#'</span>,1,<span class="string">'first'</span>);
0320 <span class="keyword">end</span>
0321 <span class="keyword">if</span> isempty(index) <span class="comment">% no comment found</span>
0322   comment=<span class="string">''</span>;
0323 <span class="keyword">else</span> <span class="comment">% split line into comment and non-comment line sections</span>
0324   comment=line(index:end);
0325   line=line(1:index-1);
0326 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 24-Feb-2017 14:46:35 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>