<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of CheckSpecification</title>
  <meta name="keywords" content="CheckSpecification">
  <meta name="description" content="CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>CheckSpecification
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function spec=CheckSpecification(specification) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields

 Usage:
   specification=CheckSpecification(specification)

 Input: DynaSim specification structure or equations

 Output:
   - DynaSim specification structure (standardized)
     .populations(i) (required): contains info for defining independent population models
       .name (default: 'pop1')      : name of population
       .size (default: 1)           : number of elements in population (i.e., # cells)
       .equations (required)        : string listing equations (see NOTE 1)
       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2)
       .parameters (default: [])    : parameters to assign across all equations in
                                      the population. provide as cell array list of
                                      key/value pairs, like
                                      {'param1',value1,'param2',value2,...}
       .conditionals (default: [])  : (see NOTE 3) if-then conditional actions
         .namespace (auto)    : string giving the namespace of the condition 
                                (pop_ or pop_mech_)
         .condition (required): string giving the condition to check
         .action (required)   : what to do if the condition is met
         .else (default: [])  : what to do if the condition is not met
       .monitors (default: [])      : (see NOTE 3) substructure with fields specifying
                                      what to record on each step of numerical
                                      integration in addition to state
                                      variables.
       .model (default: [])   : optional DynaSim model structure
     .connections(i) (default: []): contains info for linking population models
       .source (required if &gt;1 pops): name of source population (see NOTE 7)
       .target (required if &gt;1 pops): name of target population
       .mechanism_list (required)   : list of mechanisms that link two populations
       .parameters (default: [])    : parameters to assign across all equations in
                                      mechanisms in this connection's mechanism_list.

   - NOTE 1: .equations can be an equation string, cell array listing equation
       strings, or a file name pointing to a model / equations stored on disk
       (accepted file types: .eqns (equations of population), .m (function defining
       a model structure), ...)

   - NOTE 2: .mechanism_list is a cell array listing names of mechanisms to be
       included in the population or used to connect two populations. each mechanism
       name must have a mechanism file with the same name somewhere in the search
       path (the file should have extension .mech). The search path starts with the
       current directory, then the subdirectories of [dynasim]/models, and lastly
       the full matlab search path.

   - NOTE 3: conditionals and monitors are most easily specified by including
       them in .equations.
     - Example:
         spec.populations.equations='dv/dt=-v; if(v&lt;eps)(v=10); monitor o=v^2'
         data=SimulateModel(spec); figure; plot(data.time,data.pop1_o);

   - NOTE 4: &quot;pops&quot; can be used instead of &quot;populations&quot;. &quot;cons&quot; can be used
       instead of &quot;connections&quot;.

   - NOTE 5: all population info can be embedded in the equation string.
       Specify name by starting the string with 'NAME: *' (e.g., 'E: dv/dt=-v').
       Specify size by including [SIZE] after the state variable (e.g., 'dv[5]/dt=-v').
       Specify mechanism_list by including cell array listing mechanism names
       without single quotes (e.g., 'dv/dt=@current; {iNa,iK}').

   - NOTE 6: the mechanism linker target IDENTIFIER used to link mechanism
       variables and functions to population equations can be overriden by including
       @NEWIDENTIFIER in the equations and after the mechanism name. (e.g.,
       'dv/dt=@M; {iNa,iK}@M'; or .mechanism_list={'iNa@M','iK@M'}).

   - NOTE 7: &quot;direction&quot; can be used instead of &quot;source&quot; and &quot;target&quot;. The
       syntax is &quot;SOURCE-&gt;TARGET&quot; or &quot;TARGET&lt;-SOURCE&quot;. Either will be properly split
       into .source and .target fields. SOURCE and TARGET must be existing
       population names.

 Examples:
 - Example 1: obtain empty specification structure with all fields
     specification=CheckSpecification([]);

 - Example 2: standardize existing specification
     specification=CheckSpecification(specification)

 - Example 3: standardize equations in cell array
     eqns={
       's=10; r=27; b=2.666';
       'dx/dt=s*(y-x)';
       'dy/dt=r*x-y-x*z';
       'dz/dt=-b*z+x*y';
     specification=CheckSpecification(eqns);

 - Example 4: standardize equations in character array
     eqns='tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)';
     specification=CheckSpecification(eqns);

 - Example 5: standardize specification with compact field names
     s.pops.size=10;
     s.pops.equations='dv/dt=-v';
     s.cons.mechanism_list='iGABAa';
     s=CheckSpecification(s)

 - Example 6: standardize specification with everything in equation string
     s.pops.equations='E:dv[10]/dt=@M+I; {iNa,iK}@M; I=10';
     s=CheckSpecification(s)

 See also: <a href="GenerateModel.html" class="code" title="function [model,name_map]=GenerateModel(specification,varargin)">GenerateModel</a>, <a href="CheckModel.html" class="code" title="function model=CheckModel(model)">CheckModel</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="LocateModelFiles.html" class="code" title="function [paths,files]=LocateModelFiles(input)">LocateModelFiles</a>	% [paths,files]=LocateModelFiles(input)</li><li><a href="ParseModelEquations.html" class="code" title="function [model,name_map] = ParseModelEquations(text,varargin)">ParseModelEquations</a>	% model = ParseModelEquations(STRING,'param',value,...)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="ApplyModifications.html" class="code" title="function [output,modifications]=ApplyModifications(model,modifications)">ApplyModifications</a>	APPLYMODIFICATIONS - Apply modifications to DynaSim specification or model structure</li><li><a href="GenerateModel.html" class="code" title="function [model,name_map]=GenerateModel(specification,varargin)">GenerateModel</a>	% [model,name_map]=GenerateModel(specification,'option',value,...)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function list=expand_list(list)</a></li><li><a href="#_sub2" class="code">function spec=backward_compatibility(spec)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function spec=CheckSpecification(specification)</a>
0002 <span class="comment">%CHECKSPECIFICATION - standardize specification structure and auto-populate missing fields</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">%   specification=CheckSpecification(specification)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Input: DynaSim specification structure or equations</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Output:</span>
0010 <span class="comment">%   - DynaSim specification structure (standardized)</span>
0011 <span class="comment">%     .populations(i) (required): contains info for defining independent population models</span>
0012 <span class="comment">%       .name (default: 'pop1')      : name of population</span>
0013 <span class="comment">%       .size (default: 1)           : number of elements in population (i.e., # cells)</span>
0014 <span class="comment">%       .equations (required)        : string listing equations (see NOTE 1)</span>
0015 <span class="comment">%       .mechanism_list (default: []): cell array listing mechanisms (see NOTE 2)</span>
0016 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0017 <span class="comment">%                                      the population. provide as cell array list of</span>
0018 <span class="comment">%                                      key/value pairs, like</span>
0019 <span class="comment">%                                      {'param1',value1,'param2',value2,...}</span>
0020 <span class="comment">%       .conditionals (default: [])  : (see NOTE 3) if-then conditional actions</span>
0021 <span class="comment">%         .namespace (auto)    : string giving the namespace of the condition</span>
0022 <span class="comment">%                                (pop_ or pop_mech_)</span>
0023 <span class="comment">%         .condition (required): string giving the condition to check</span>
0024 <span class="comment">%         .action (required)   : what to do if the condition is met</span>
0025 <span class="comment">%         .else (default: [])  : what to do if the condition is not met</span>
0026 <span class="comment">%       .monitors (default: [])      : (see NOTE 3) substructure with fields specifying</span>
0027 <span class="comment">%                                      what to record on each step of numerical</span>
0028 <span class="comment">%                                      integration in addition to state</span>
0029 <span class="comment">%                                      variables.</span>
0030 <span class="comment">%       .model (default: [])   : optional DynaSim model structure</span>
0031 <span class="comment">%     .connections(i) (default: []): contains info for linking population models</span>
0032 <span class="comment">%       .source (required if &gt;1 pops): name of source population (see NOTE 7)</span>
0033 <span class="comment">%       .target (required if &gt;1 pops): name of target population</span>
0034 <span class="comment">%       .mechanism_list (required)   : list of mechanisms that link two populations</span>
0035 <span class="comment">%       .parameters (default: [])    : parameters to assign across all equations in</span>
0036 <span class="comment">%                                      mechanisms in this connection's mechanism_list.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   - NOTE 1: .equations can be an equation string, cell array listing equation</span>
0039 <span class="comment">%       strings, or a file name pointing to a model / equations stored on disk</span>
0040 <span class="comment">%       (accepted file types: .eqns (equations of population), .m (function defining</span>
0041 <span class="comment">%       a model structure), ...)</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   - NOTE 2: .mechanism_list is a cell array listing names of mechanisms to be</span>
0044 <span class="comment">%       included in the population or used to connect two populations. each mechanism</span>
0045 <span class="comment">%       name must have a mechanism file with the same name somewhere in the search</span>
0046 <span class="comment">%       path (the file should have extension .mech). The search path starts with the</span>
0047 <span class="comment">%       current directory, then the subdirectories of [dynasim]/models, and lastly</span>
0048 <span class="comment">%       the full matlab search path.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%   - NOTE 3: conditionals and monitors are most easily specified by including</span>
0051 <span class="comment">%       them in .equations.</span>
0052 <span class="comment">%     - Example:</span>
0053 <span class="comment">%         spec.populations.equations='dv/dt=-v; if(v&lt;eps)(v=10); monitor o=v^2'</span>
0054 <span class="comment">%         data=SimulateModel(spec); figure; plot(data.time,data.pop1_o);</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%   - NOTE 4: &quot;pops&quot; can be used instead of &quot;populations&quot;. &quot;cons&quot; can be used</span>
0057 <span class="comment">%       instead of &quot;connections&quot;.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   - NOTE 5: all population info can be embedded in the equation string.</span>
0060 <span class="comment">%       Specify name by starting the string with 'NAME: *' (e.g., 'E: dv/dt=-v').</span>
0061 <span class="comment">%       Specify size by including [SIZE] after the state variable (e.g., 'dv[5]/dt=-v').</span>
0062 <span class="comment">%       Specify mechanism_list by including cell array listing mechanism names</span>
0063 <span class="comment">%       without single quotes (e.g., 'dv/dt=@current; {iNa,iK}').</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%   - NOTE 6: the mechanism linker target IDENTIFIER used to link mechanism</span>
0066 <span class="comment">%       variables and functions to population equations can be overriden by including</span>
0067 <span class="comment">%       @NEWIDENTIFIER in the equations and after the mechanism name. (e.g.,</span>
0068 <span class="comment">%       'dv/dt=@M; {iNa,iK}@M'; or .mechanism_list={'iNa@M','iK@M'}).</span>
0069 <span class="comment">%</span>
0070 <span class="comment">%   - NOTE 7: &quot;direction&quot; can be used instead of &quot;source&quot; and &quot;target&quot;. The</span>
0071 <span class="comment">%       syntax is &quot;SOURCE-&gt;TARGET&quot; or &quot;TARGET&lt;-SOURCE&quot;. Either will be properly split</span>
0072 <span class="comment">%       into .source and .target fields. SOURCE and TARGET must be existing</span>
0073 <span class="comment">%       population names.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% Examples:</span>
0076 <span class="comment">% - Example 1: obtain empty specification structure with all fields</span>
0077 <span class="comment">%     specification=CheckSpecification([]);</span>
0078 <span class="comment">%</span>
0079 <span class="comment">% - Example 2: standardize existing specification</span>
0080 <span class="comment">%     specification=CheckSpecification(specification)</span>
0081 <span class="comment">%</span>
0082 <span class="comment">% - Example 3: standardize equations in cell array</span>
0083 <span class="comment">%     eqns={</span>
0084 <span class="comment">%       's=10; r=27; b=2.666';</span>
0085 <span class="comment">%       'dx/dt=s*(y-x)';</span>
0086 <span class="comment">%       'dy/dt=r*x-y-x*z';</span>
0087 <span class="comment">%       'dz/dt=-b*z+x*y';</span>
0088 <span class="comment">%     specification=CheckSpecification(eqns);</span>
0089 <span class="comment">%</span>
0090 <span class="comment">% - Example 4: standardize equations in character array</span>
0091 <span class="comment">%     eqns='tau=10; R=10; E=-70; dV/dt=(E-V+R*1.55)/tau; if(V&gt;-55)(V=-75)';</span>
0092 <span class="comment">%     specification=CheckSpecification(eqns);</span>
0093 <span class="comment">%</span>
0094 <span class="comment">% - Example 5: standardize specification with compact field names</span>
0095 <span class="comment">%     s.pops.size=10;</span>
0096 <span class="comment">%     s.pops.equations='dv/dt=-v';</span>
0097 <span class="comment">%     s.cons.mechanism_list='iGABAa';</span>
0098 <span class="comment">%     s=CheckSpecification(s)</span>
0099 <span class="comment">%</span>
0100 <span class="comment">% - Example 6: standardize specification with everything in equation string</span>
0101 <span class="comment">%     s.pops.equations='E:dv[10]/dt=@M+I; {iNa,iK}@M; I=10';</span>
0102 <span class="comment">%     s=CheckSpecification(s)</span>
0103 <span class="comment">%</span>
0104 <span class="comment">% See also: GenerateModel, CheckModel</span>
0105 
0106 <span class="comment">% check if input is a string or cell with equations and package in spec structure</span>
0107 <span class="keyword">if</span> ischar(specification) || iscell(specification)
0108   spec.populations.equations=specification;
0109 <span class="keyword">elseif</span> isstruct(specification)
0110   spec=specification;
0111 <span class="keyword">elseif</span> isempty(specification)
0112   spec=struct;
0113 <span class="keyword">else</span>
0114   error(<span class="string">'specification must be a DynaSim specification structure or a string with equations or sub-model filename.'</span>);
0115 <span class="keyword">end</span>
0116 
0117 spec=<a href="#_sub2" class="code" title="subfunction spec=backward_compatibility(spec)">backward_compatibility</a>(spec);
0118 pop_field_order={<span class="string">'name'</span>,<span class="string">'size'</span>,<span class="string">'equations'</span>,<span class="string">'mechanism_list'</span>,<span class="string">'parameters'</span>,<span class="keyword">...</span>
0119   <span class="string">'conditionals'</span>,<span class="string">'monitors'</span>,<span class="string">'model'</span>};
0120 con_field_order={<span class="string">'source'</span>,<span class="string">'target'</span>,<span class="string">'mechanism_list'</span>,<span class="string">'parameters'</span>};
0121 
0122 <span class="keyword">if</span> ~isfield(spec,<span class="string">'populations'</span>)
0123   spec.populations.name=<span class="string">'pop1'</span>;
0124 <span class="keyword">end</span>
0125 <span class="keyword">if</span> ~isfield(spec,<span class="string">'connections'</span>)
0126   spec.connections=[];
0127 <span class="keyword">end</span>
0128 
0129 <span class="comment">% 1.0 standardize populations</span>
0130 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'name'</span>)
0131   spec.populations(1).name=<span class="string">'pop1'</span>;
0132 <span class="keyword">end</span>
0133 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'size'</span>)
0134   spec.populations(1).size=1;
0135 <span class="keyword">end</span>
0136 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'equations'</span>)
0137   spec.populations(1).equations=[];
0138 <span class="keyword">end</span>
0139 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'mechanism_list'</span>)
0140   spec.populations(1).mechanism_list=[];
0141 <span class="keyword">end</span>
0142 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'parameters'</span>)
0143   spec.populations(1).parameters={};
0144 <span class="keyword">end</span>
0145 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'conditionals'</span>)
0146   spec.populations(1).conditionals=[];
0147 <span class="keyword">end</span>
0148 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'monitors'</span>)
0149   spec.populations(1).monitors=[];
0150 <span class="keyword">end</span>
0151 <span class="keyword">if</span> ~isfield(spec.populations,<span class="string">'model'</span>)
0152   spec.populations(1).model=[];
0153 <span class="keyword">end</span>
0154 <span class="comment">% special case: split equations with '[...][...]...[...]' into multiple populations</span>
0155 <span class="keyword">for</span> i=1:length(spec.populations)
0156   eqn=spec.populations(i).equations;
0157   <span class="keyword">if</span> ~isempty(eqn) &amp;&amp; ischar(eqn)
0158     <span class="keyword">if</span> ~isempty(regexp(eqn,<span class="string">'\[[a-z_A-Z].*\]'</span>,<span class="string">'match'</span>,<span class="string">'once'</span>))
0159       <span class="comment">% create extra population</span>
0160       tmp=regexp(eqn(2:end-1),<span class="string">'\],?\s*\['</span>,<span class="string">'split'</span>);
0161       spec.populations(i).equations=tmp{1};
0162       <span class="keyword">for</span> j=2:length(tmp)
0163         spec.populations(end+1)=spec.populations(i);
0164         spec.populations(end).equations=tmp{j};
0165         spec.populations(end).name=sprintf(<span class="string">'pop%g'</span>,length(spec.populations));
0166       <span class="keyword">end</span>
0167     <span class="keyword">end</span>
0168   <span class="keyword">end</span>
0169 <span class="keyword">end</span>
0170 <span class="comment">% standardize each population separately</span>
0171 <span class="keyword">for</span> i=1:length(spec.populations)
0172   <span class="comment">% population names</span>
0173   <span class="keyword">if</span> isempty(spec.populations(i).name)
0174     spec.populations(i).name=sprintf(<span class="string">'pop%g'</span>,i);
0175   <span class="keyword">end</span>
0176   <span class="comment">% population sizes</span>
0177   <span class="keyword">if</span> isempty(spec.populations(i).size)
0178     spec.populations(i).size=1;
0179   <span class="keyword">end</span>
0180   <span class="comment">% make mechanism list a cell array of mechanism names</span>
0181   <span class="keyword">if</span> ischar(spec.populations(i).mechanism_list)
0182     spec.populations(i).mechanism_list={spec.populations(i).mechanism_list};
0183   <span class="keyword">end</span>
0184   <span class="comment">% parameter cell arrays</span>
0185   <span class="keyword">if</span> ~iscell(spec.populations(i).parameters)
0186     spec.populations(i).parameters={};
0187   <span class="keyword">end</span>
0188   <span class="comment">% standardize equations</span>
0189   <span class="keyword">if</span> ~isempty(spec.populations(i).equations)
0190     <span class="comment">% convert cell array of equations into character array</span>
0191     <span class="keyword">if</span> iscell(spec.populations(i).equations)
0192       eqns=spec.populations(i).equations;
0193       <span class="keyword">for</span> k=1:length(eqns)
0194         eqn=eqns{k};
0195         <span class="keyword">if</span> ~isempty(eqn) &amp;&amp; ~strcmp(eqn(end),<span class="string">';'</span>)
0196           eqns{k}(end+1)=<span class="string">';'</span>;
0197         <span class="keyword">end</span>
0198       <span class="keyword">end</span>
0199       spec.populations(i).equations=[eqns{:}];
0200     <span class="keyword">end</span>
0201     <span class="comment">% extract name from equations (e.g., TC:...)</span>
0202     eqn=spec.populations(i).equations;
0203     name=regexp(eqn,<span class="string">'^\w+:'</span>,<span class="string">'match'</span>,<span class="string">'once'</span>);
0204     <span class="keyword">if</span> ~isempty(name)
0205       <span class="comment">% remove name indicator from equation</span>
0206       eqn=strrep(eqn,name,<span class="string">''</span>);
0207       <span class="comment">% store name in specification</span>
0208       name=regexp(name,<span class="string">'^(\w+):'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0209       spec.populations(i).name=name{1};
0210       spec.populations(i).equations=eqn;
0211     <span class="keyword">end</span>
0212     <span class="comment">% extract size from equations if present (eg, v[4]'=.., dv[4]/dt=...)</span>
0213     eqn=spec.populations(i).equations;
0214     pattern=<span class="string">'((\w+(\[\d+\])'')|(d\w+(\[\d+\])/dt))\s*='</span>; <span class="comment">% support size spec, dv[4]/dt</span>
0215     <span class="comment">% extract all differentials with size specification</span>
0216     LHSs=regexp(eqn,pattern,<span class="string">'match'</span>);
0217     <span class="keyword">if</span> ~isempty(LHSs)
0218       <span class="comment">% extract sizes from all differentials (eg, 4 from v[4] or dv[4]/dt)</span>
0219       szs=nan(1,length(LHSs));
0220       <span class="keyword">for</span> k=1:length(LHSs)
0221         tmp=regexp(LHSs{k},<span class="string">'\w+\[(\d+)\]'''</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0222         <span class="keyword">if</span> isempty(tmp)
0223           tmp=regexp(LHSs{k},<span class="string">'d\w+\[(\d+)\]/dt'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>);
0224         <span class="keyword">end</span>
0225         szs(k)=str2num(tmp{1});
0226         <span class="comment">% remove size from ODE in population equations</span>
0227         old=LHSs{k};
0228         new=strrep(LHSs{k},[<span class="string">'['</span> tmp{1} <span class="string">']'</span>],<span class="string">''</span>);
0229         eqn=strrep(eqn,old,new);
0230       <span class="keyword">end</span>
0231       <span class="comment">% check that all vars in same population have same size</span>
0232       <span class="keyword">if</span> ~all(szs==szs(1))
0233         error(<span class="string">'all variables in same population must have same size. split ODEs with different sizes into different populations.'</span>);
0234       <span class="keyword">end</span>
0235       spec.populations(i).equations=eqn;
0236       spec.populations(i).size=szs(1);
0237     <span class="keyword">end</span>
0238     <span class="comment">% add mechanisms embedded in equations to mechanism_list ({M1,M2,...})</span>
0239     <span class="comment">% ----------</span>
0240     <span class="comment">% todo: make the following a subfunction and apply it also to connection</span>
0241     <span class="comment">% mechanism lists (eg, for cons.mechanism_list='{AMPA,NMDA}@M')</span>
0242     <span class="comment">% ----------</span>
0243     <span class="comment">% extract mechanism list from equations</span>
0244     <span class="comment">%mech_lists=regexp(spec.populations(i).equations,'\s*{.*}\s*;?\s*','match');</span>
0245     <span class="comment">%mech_lists=regexp(spec.populations(i).equations,'\s*(\w+:)?{.*}\s*(@\w+)?;?\s*','match');</span>
0246      mech_lists=regexp(spec.populations(i).equations,<span class="string">'\s*(\w+:)?{[\w\d@:,]*}\s*(@\w+)?;?\s*'</span>,<span class="string">'match'</span>);
0247     <span class="comment">% test: mech_list=regexp('v''=@M+sin(2*pi*t); {iNa, iK}','{.*}','match');</span>
0248     <span class="keyword">if</span> ~isempty(mech_lists)
0249       <span class="keyword">for</span> k=1:length(mech_lists)
0250         mech_list=strtrim(mech_lists{k});
0251         <span class="comment">% remove mechanism list from equations</span>
0252         spec.populations(i).equations=strtrim(strrep(spec.populations(i).equations,mech_list,<span class="string">''</span>));
0253         <span class="comment">% append external link alias to each internal mechanism name (eg, {a,b}@M, alias @M)</span>
0254         external_link=regexp(mech_list,<span class="string">'}(@[\w\d]+;?)'</span>,<span class="string">'tokens'</span>);        
0255         <span class="keyword">if</span> ~isempty(external_link)
0256           <span class="comment">% get external link alias</span>
0257           external_link=[external_link{:}];
0258           <span class="comment">% remove external link alias from mech_list</span>
0259           mech_list=strrep(mech_list,external_link{1},<span class="string">''</span>);
0260           <span class="comment">% remove ';' from alias before appending to mech names</span>
0261           external_link=strrep(external_link{1},<span class="string">';'</span>,<span class="string">''</span>); 
0262           <span class="comment">% get list of mechanism names in cell array</span>
0263           <span class="comment">%words=regexp(mech_list,'[a-zA-Z]+[\w:]*','match');</span>
0264           words=regexp(mech_list(2:end-1),<span class="string">','</span>,<span class="string">'split'</span>);
0265           <span class="comment">% append external link alias to each mechanism name</span>
0266           <span class="keyword">for</span> w=1:length(words)
0267             mech_list=strrep(mech_list,words{w},[words{w} external_link]);
0268           <span class="keyword">end</span>
0269         <span class="keyword">end</span>
0270         <span class="comment">% prepend host name to each internal mechanism name (eg,</span>
0271         <span class="comment">% infbrain:{a,b} -&gt; {infbrain:a,infbrain:b}</span>
0272         host_name=regexp(mech_list,<span class="string">';?\s*([\w\d]+):{'</span>,<span class="string">'tokens'</span>,<span class="string">'once'</span>); 
0273         <span class="keyword">if</span> ~isempty(host_name)
0274           <span class="comment">% get external link alias</span>
0275           host_name=[host_name{:}];
0276           <span class="comment">% remove external link alias from mech_list</span>
0277           mech_list=strrep(mech_list,[host_name <span class="string">':'</span>],<span class="string">''</span>);
0278           <span class="comment">% get list of mechanism names in cell array</span>
0279           words=regexp(mech_list(2:end-1),<span class="string">','</span>,<span class="string">'split'</span>);
0280           <span class="comment">% append external link alias to each mechanism name</span>
0281           <span class="keyword">for</span> w=1:length(words)
0282             mech_list=strrep(mech_list,words{w},[host_name <span class="string">':'</span> words{w}]);
0283           <span class="keyword">end</span>
0284         <span class="keyword">end</span>
0285         <span class="comment">% split into list of mechanism names</span>
0286         mechanisms=regexp(mech_list,<span class="string">'[\w:@]+'</span>,<span class="string">'match'</span>);        
0287         <span class="comment">% append mechanism from equations to mechanism_list</span>
0288         <span class="keyword">if</span> iscell(spec.populations(i).mechanism_list)
0289           spec.populations(i).mechanism_list=cat(2,mechanisms,spec.populations(i).mechanism_list);
0290         <span class="keyword">else</span>
0291           spec.populations(i).mechanism_list=mechanisms;
0292         <span class="keyword">end</span>
0293       <span class="keyword">end</span>
0294     <span class="keyword">end</span>
0295     <span class="comment">% extract population-level parameters from equations</span>
0296     eqn=spec.populations(i).equations;
0297     p=getfield(<a href="ParseModelEquations.html" class="code" title="function [model,name_map] = ParseModelEquations(text,varargin)">ParseModelEquations</a>(eqn),<span class="string">'parameters'</span>);
0298     <span class="keyword">if</span> ~isempty(p)
0299       param_name=fieldnames(p);
0300       param_value=struct2cell(p);
0301       <span class="keyword">for</span> l=1:length(param_name)
0302         value=eval(param_value{l});
0303         <span class="keyword">if</span> isempty(spec.populations(i).parameters)
0304           spec.populations(i).parameters={param_name{l},value};
0305         <span class="keyword">elseif</span> ~ismember(param_name{l},spec.populations(i).parameters(1:2:end))
0306           spec.populations(i).parameters{end+1}=param_name{l};
0307           spec.populations(i).parameters{end+1}=value;
0308         <span class="keyword">end</span>
0309       <span class="keyword">end</span>
0310     <span class="keyword">end</span>
0311     <span class="comment">% incorporate user-supplied parameters in pop equations if used in them</span>
0312     <span class="keyword">if</span> ~isempty(spec.populations(i).parameters)
0313       keys=spec.populations(i).parameters(1:2:end);
0314       vals=spec.populations(i).parameters(2:2:end);
0315       <span class="comment">% add user-supplied params to pop equations if present in them</span>
0316       <span class="comment">% approach: look for populations.parameters in population.equations that are not explicitly</span>
0317       <span class="comment">% defined in population.equations and append their definition explicitly to pop.eqns</span>
0318       eqn=spec.populations(i).equations;
0319       <span class="comment">% get list of parameters/variables/functions in population equations</span>
0320       words=unique(regexp(eqn,<span class="string">'[a-zA-Z]+\w*'</span>,<span class="string">'match'</span>));
0321       <span class="comment">% find those in user-supplied parameters</span>
0322       found_words=words(ismember(words,keys));
0323       <span class="keyword">if</span> ~isempty(found_words)     
0324         <span class="comment">% set in population equations if not already defined there</span>
0325         <span class="keyword">for</span> ff=1:length(found_words)
0326           found_word=found_words{ff};
0327           <span class="comment">% check if not explicitly set in population equations</span>
0328           <span class="keyword">if</span> isempty(regexp(eqn,[<span class="string">';\s*'</span> found_word <span class="string">'\s*='</span>],<span class="string">'once'</span>)) &amp;&amp; <span class="keyword">...</span><span class="comment"> % not in middle or at end</span>
0329              isempty(regexp(eqn,[<span class="string">'^'</span> found_word <span class="string">'\s*='</span>],<span class="string">'once'</span>)) <span class="comment">% not at beginning</span>
0330             <span class="comment">% explicitly set in population equations</span>
0331             <span class="keyword">if</span> eqn(end)~=<span class="string">';'</span>, eqn(end+1)=<span class="string">';'</span>; <span class="keyword">end</span> <span class="comment">% add semicolon if necessary</span>
0332             precision=8; <span class="comment">% number of digits allowed for user-supplied values</span>
0333             found_value = toString(vals{strcmp(found_word,keys)},precision);
0334             eqn=[eqn sprintf(<span class="string">' %s=%s;'</span>,found_word,found_value)];
0335           <span class="keyword">end</span>
0336         <span class="keyword">end</span>
0337         spec.populations(i).equations=eqn;
0338       <span class="keyword">end</span>
0339     <span class="keyword">end</span>
0340   <span class="keyword">end</span>
0341   <span class="comment">% expand mechanism list if any element is itself a list of mechanisms (eg, {'iCa','{CaBuffer,iCan}'} or '{CaBuffer,iCan}')</span>
0342   spec.populations(i).mechanism_list=<a href="#_sub1" class="code" title="subfunction list=expand_list(list)">expand_list</a>(spec.populations(i).mechanism_list);  
0343 <span class="keyword">end</span>
0344 
0345 <span class="comment">% 2.0 standardize connections</span>
0346 <span class="keyword">if</span> ~isempty(spec.connections)
0347   <span class="comment">% check for proper fields in connections substructure</span>
0348   <span class="keyword">if</span> ~isfield(spec.connections,<span class="string">'source'</span>)
0349     spec.connections(1).source=[];
0350   <span class="keyword">end</span>
0351   <span class="keyword">if</span> ~isfield(spec.connections,<span class="string">'target'</span>)
0352     spec.connections(1).target=[];
0353   <span class="keyword">end</span>
0354   <span class="keyword">if</span> ~isfield(spec.connections,<span class="string">'mechanism_list'</span>)
0355     spec.connections(1).mechanism_list=[];
0356   <span class="keyword">end</span>
0357   <span class="keyword">if</span> ~isfield(spec.connections,<span class="string">'parameters'</span>)
0358     spec.connections(1).parameters={};
0359   <span class="keyword">end</span>  
0360 <span class="keyword">end</span>
0361 <span class="keyword">for</span> i=1:length(spec.connections)
0362   <span class="keyword">if</span> isempty(spec.connections(i).source) &amp;&amp; length(spec.populations)==1
0363     spec.connections(i).source=spec.populations(1).name;
0364     spec.connections(i).target=spec.populations(1).name;
0365   <span class="keyword">elseif</span> isempty(spec.connections(i).source) &amp;&amp; length(spec.populations)&gt;1
0366     error(<span class="string">'connection source and target populations must be specified in specification.connections when the model contains more than one population.'</span>);
0367   <span class="keyword">end</span>
0368   <span class="comment">% make mechanism list a cell array of mechanism names</span>
0369   <span class="keyword">if</span> ischar(spec.connections(i).mechanism_list)
0370     spec.connections(i).mechanism_list={spec.connections(i).mechanism_list};
0371   <span class="keyword">end</span>
0372   <span class="comment">% expand mechanism list if any element is itself a list of mechanisms (eg, {'AMPA','{GABAa,GABAb}'} or '{GABAa,GABAb}')</span>
0373   spec.connections(i).mechanism_list=<a href="#_sub1" class="code" title="subfunction list=expand_list(list)">expand_list</a>(spec.connections(i).mechanism_list);
0374   <span class="comment">% parameter cell arrays</span>
0375   <span class="keyword">if</span> ~iscell(spec.connections(i).parameters)
0376     spec.connections(i).parameters={};
0377   <span class="keyword">end</span>
0378 <span class="keyword">end</span>
0379 
0380 <span class="comment">% remove populations with size==0</span>
0381 sizes=[spec.populations.size];
0382 <span class="keyword">if</span> any(sizes==0)
0383   <span class="comment">% find null populations</span>
0384   null_pops=find(sizes==0);
0385   null_names={spec.populations(null_pops).name};
0386   <span class="comment">% remove from .populations</span>
0387   spec.populations(null_pops)=[];
0388   <span class="comment">% remove from connections</span>
0389   <span class="keyword">if</span> ~isempty(spec.connections)
0390     sources={spec.connections.source};
0391     targets={spec.connections.target};
0392     null_conns=ismember(sources,null_names) | ismember(targets,null_names);
0393     spec.connections(null_conns)=[];
0394   <span class="keyword">end</span>
0395 <span class="keyword">end</span>    
0396 
0397 <span class="comment">% 3.0 sort fields</span>
0398 <span class="comment">% remove extra fields</span>
0399 otherfields=setdiff(fieldnames(spec.populations),pop_field_order);
0400 spec.populations=rmfield(spec.populations,otherfields);
0401 <span class="comment">% sort standardized fields</span>
0402 spec.populations=orderfields(spec.populations,pop_field_order);
0403 <span class="keyword">if</span> isstruct(spec.connections)
0404   otherfields=setdiff(fieldnames(spec.connections),con_field_order);
0405   spec.connections=rmfield(spec.connections,otherfields);
0406   spec.connections=orderfields(spec.connections,con_field_order);
0407 <span class="keyword">end</span>
0408 
0409 <span class="comment">% 4.0 replace mechanism names by full file names</span>
0410 <span class="comment">% this is necessary so that regenerated models will use the same mechanism</span>
0411 <span class="comment">% files to recreate the model (e.g., when a cluster job simulates a</span>
0412 <span class="comment">% modified version of an original base model).</span>
0413 [~,files]=<a href="LocateModelFiles.html" class="code" title="function [paths,files]=LocateModelFiles(input)">LocateModelFiles</a>(spec);
0414 <span class="keyword">if</span> ~isempty(files)
0415   fnames={};
0416   <span class="keyword">for</span> f=1:length(files)
0417     [~,name]=fileparts(files{f});
0418     fnames{f}=name;
0419   <span class="keyword">end</span>
0420   <span class="comment">% update population and connection mechanism lists</span>
0421   fields={<span class="string">'populations'</span>,<span class="string">'connections'</span>};
0422   <span class="keyword">for</span> f=1:length(fields)
0423     object=fields{f};
0424     <span class="keyword">for</span> i=1:length(spec.(object))
0425       <span class="keyword">for</span> j=1:length(spec.(object)(i).mechanism_list)
0426         mech=spec.(object)(i).mechanism_list{j};
0427         <span class="keyword">if</span> ismember(mech,fnames)
0428           spec.(object)(i).mechanism_list{j}=files{find(ismember(fnames,mech),1,<span class="string">'first'</span>)};
0429         <span class="keyword">end</span>
0430       <span class="keyword">end</span>
0431     <span class="keyword">end</span>
0432   <span class="keyword">end</span>
0433 <span class="keyword">end</span>
0434 
0435 <a name="_sub1" href="#_subfunctions" class="code">function list=expand_list(list)</a>
0436 <span class="comment">% expand mechanism list if any element is itself a list of mechanisms (eg, {'AMPA','{GABAa,GABAb}'} or '{GABAa,GABAb}')</span>
0437 <span class="keyword">if</span> isempty(list)
0438   <span class="keyword">return</span>;
0439 <span class="keyword">end</span>
0440 <span class="keyword">if</span> any(~cellfun(@isempty,regexp(list,<span class="string">'[{,}]+'</span>)))
0441   mechs={};
0442   <span class="keyword">for</span> k=1:length(list)
0443     tmp=regexp(list{k},<span class="string">'\w+'</span>,<span class="string">'match'</span>);
0444     mechs=cat(2,mechs,tmp{:});
0445   <span class="keyword">end</span>
0446   list=mechs;
0447 <span class="keyword">end</span>
0448 
0449 <a name="_sub2" href="#_subfunctions" class="code">function spec=backward_compatibility(spec)</a>
0450 <span class="comment">% purpose: change name of fields from old to new convention</span>
0451 <span class="comment">% rename &quot;nodes&quot; or &quot;entities&quot; to &quot;populations&quot;</span>
0452 <span class="keyword">if</span> isfield(spec,<span class="string">'nodes'</span>)
0453   spec.populations=spec.nodes;
0454   spec=rmfield(spec,<span class="string">'nodes'</span>);
0455 <span class="keyword">end</span>
0456 <span class="keyword">if</span> isfield(spec,<span class="string">'cells'</span>)
0457   spec.populations=spec.cells;
0458   spec=rmfield(spec,<span class="string">'cells'</span>);
0459 <span class="keyword">end</span>
0460 <span class="keyword">if</span> isfield(spec,<span class="string">'entities'</span>)
0461   spec.populations=spec.entities;
0462   spec=rmfield(spec,<span class="string">'entities'</span>);
0463 <span class="keyword">end</span>
0464 <span class="keyword">if</span> isfield(spec,<span class="string">'pops'</span>)
0465   spec.populations=spec.pops;
0466   spec=rmfield(spec,<span class="string">'pops'</span>);
0467 <span class="keyword">end</span>
0468 <span class="keyword">if</span> isfield(spec,<span class="string">'cons'</span>)
0469   spec.connections=spec.cons;
0470   spec=rmfield(spec,<span class="string">'cons'</span>);
0471 <span class="keyword">end</span>
0472 <span class="keyword">if</span> isfield(spec,<span class="string">'populations'</span>)
0473   <span class="comment">% rename population &quot;label&quot; to &quot;name&quot;</span>
0474   <span class="keyword">if</span> isfield(spec.populations,<span class="string">'label'</span>)
0475     <span class="keyword">for</span> i=1:length(spec.populations)
0476       spec.populations(i).name=spec.populations(i).label;
0477     <span class="keyword">end</span>
0478     spec.populations=rmfield(spec.populations,<span class="string">'label'</span>);
0479   <span class="keyword">end</span>
0480   <span class="comment">% rename population &quot;multiplicity&quot; to &quot;size&quot;</span>
0481   <span class="keyword">if</span> isfield(spec.populations,<span class="string">'multiplicity'</span>)
0482     <span class="keyword">for</span> i=1:length(spec.populations)
0483       spec.populations(i).size=spec.populations(i).multiplicity;
0484     <span class="keyword">end</span>
0485     spec.populations=rmfield(spec.populations,<span class="string">'multiplicity'</span>);
0486   <span class="keyword">end</span>
0487   <span class="comment">% rename population &quot;dynamics&quot; to &quot;equations&quot;</span>
0488   <span class="keyword">if</span> isfield(spec.populations,<span class="string">'dynamics'</span>)
0489     <span class="keyword">for</span> i=1:length(spec.populations)
0490       spec.populations(i).equations=spec.populations(i).dynamics;
0491     <span class="keyword">end</span>
0492     spec.populations=rmfield(spec.populations,<span class="string">'dynamics'</span>);
0493   <span class="keyword">end</span>
0494   <span class="comment">% rename population &quot;mechanisms&quot; to &quot;mechanism_list&quot;</span>
0495   <span class="keyword">if</span> isfield(spec.populations,<span class="string">'mechanisms'</span>)
0496     <span class="keyword">for</span> i=1:length(spec.populations)
0497       spec.populations(i).mechanism_list=spec.populations(i).mechanisms;
0498     <span class="keyword">end</span>
0499     spec.populations=rmfield(spec.populations,<span class="string">'mechanisms'</span>);
0500   <span class="keyword">end</span>
0501 <span class="keyword">end</span>
0502 <span class="comment">% check for old (pre,post) organization of connections substructure</span>
0503 <span class="keyword">if</span> isfield(spec,<span class="string">'connections'</span>) &amp;&amp; size(spec.connections,1)&gt;1
0504   <span class="comment">% convert to linear connections structure array</span>
0505   old=spec.connections;
0506   spec=rmfield(spec,<span class="string">'connections'</span>);
0507   index=1;
0508   <span class="keyword">for</span> i=1:size(old,1)
0509     <span class="keyword">for</span> j=1:size(old,2)
0510       <span class="keyword">if</span> ~isempty(old(i,j).mechanisms)
0511         spec.connections(index).source=spec.populations(i).name;
0512         spec.connections(index).target=spec.populations(j).name;
0513         <span class="keyword">if</span> isfield(old,<span class="string">'mechanisms'</span>)
0514           spec.connections(index).mechanism_list=old(i,j).mechanisms;
0515         <span class="keyword">elseif</span> isfield(old,<span class="string">'mechanism_list'</span>)
0516           spec.connections(index).mechanism_list=old(i,j).mechanism_list;
0517         <span class="keyword">end</span>
0518         <span class="keyword">if</span> isfield(old,<span class="string">'parameters'</span>)
0519           spec.connections(index).parameters=old(i,j).parameters;
0520         <span class="keyword">end</span>
0521         index=index+1;
0522       <span class="keyword">end</span>
0523     <span class="keyword">end</span>
0524   <span class="keyword">end</span>
0525 <span class="keyword">end</span>
0526 <span class="keyword">if</span> isfield(spec,<span class="string">'connections'</span>) &amp;&amp; isfield(spec.connections,<span class="string">'direction'</span>)
0527   <span class="keyword">for</span> i=1:length(spec.connections)
0528     <span class="keyword">if</span> ischar(spec.connections(i).direction)
0529       str=spec.connections(i).direction;
0530       <span class="keyword">if</span> any(regexp(str,<span class="string">'-&gt;'</span>,<span class="string">'once'</span>))
0531         pops=regexp(str,<span class="string">'-&gt;'</span>,<span class="string">'split'</span>);
0532         spec.connections(i).source=pops{1};
0533         spec.connections(i).target=pops{2};
0534       <span class="keyword">elseif</span> any(regexp(str,<span class="string">'&lt;-'</span>,<span class="string">'once'</span>))
0535         pops=regexp(str,<span class="string">'&lt;-'</span>,<span class="string">'split'</span>);
0536         spec.connections(i).source=pops{2};
0537         spec.connections(i).target=pops{1};
0538       <span class="keyword">end</span>
0539     <span class="keyword">end</span>
0540   <span class="keyword">end</span>
0541   spec.connections=rmfield(spec.connections,<span class="string">'direction'</span>);
0542 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 24-Feb-2017 14:46:35 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>