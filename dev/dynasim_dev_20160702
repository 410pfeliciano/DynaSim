11am Skype into DynaSim

- GUI zscore
- GUI connectivity
- DynaSim speed comparisons

- confirm/make compatible with Octave
- fix/explore speed of compiled version

------------------------------------------

SelectPlotData
AutoscaleSimPlot
UpdateSimPlots

reply to Bryan
reply to Stephanie
notify David Mashburn


Hi Earl,

I'm looking forward to starting my MURI postdoc with you and Mike in a couple weeks. Is there anything administrative I should be doing now to prepare? 

[lab presentation]
[desk]

-----------------------------------------------------------------

Connectivity approach:
- only update connectivity view if on "connections" tab
- get list of connectivity matrices for listbox from model.fixed_variables
- calculate matrix for display by evaluating parameters and fixed_variables in model=GenerateModel(SPEC)
	- consider storing matrix in userdata?
- update model by 

*alternatively: do everything using SPEC
- 

----------------------------------------------------------------

DEBUG:

Does not work: 
iampa={
  'gSYN=.5; ESYN=0; tauD=2; tauR=0.4; delay=15'
  'netcon=ones(N_pre,N_post)'
  'f(x) = 1*(exp(-x/tauD)-exp(-x/tauR)).*(x>0)'
  'Isyn(V) = gSYN.*(sum(f(t-tspike_pre-delay))*netcon).*(V-ESYN)'
  '@isyn += -Isyn(V_post)'
  'monitor Isyn'
};

Works:
  'Isyn(X) = gSYN.*(sum(f(t-tspike_pre-delay))*netcon).*(X-ESYN)'

The problem is with the expression for evaluating the monitored function Isyn.
With argument "X", "X" is replaced in model.functions by the state variable in dsPropagateNamespaces(?).
With argument "V", "V" is not replaced by "E_V" in model.ODEs but not in model.functions; therefore, monitor expression taken from model.functions uses "V" and not "E_V".

*******************
Potential Solution:
*******************
Need to substitute the proper state variable into model.functions based on linker arguments when writing the monitor expression

																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																										


-----------------------------------------------------------------
GUI:
[~]- fix undo
[~]- add SAVE MODEL / OPEN MODEL
[x] - make invisible: "View history", "+ Version", "NEW SWEEP", unused menu options
[later] - add connectivity matrix viewer (do later)

General dev:
[x] incorporate Windows patch
[x] remove all terms @* from equations before creating solve_file


Big devs:
- event-based model updating (e.g., STDP): 
	- store spike times for all populations
		e.g.) E.last_y_spike_times [1 ... Npop]
	- update population model based on functions of spike times from multiple populations
		e.g.) LIF networks   (http://www.cns.nyu.edu/~eorhan/notes/lif-neuron.pdf, page 5)
		e.g.) STDP   (http://www.scholarpedia.org/article/Spike-timing_dependent_plasticity, online implementation)
- delays
	- find variables with delays
	- select appropriate index from state vector on each time step

Final pre-paper:
- speed comparisons

----------------------------------------------------------------------

event-based updates:

Isyn: 
isyn=(w*netcon)*alpha(t-t_pre)

STDP:
isyn=g*w*(V-E)
discrete:
  w(0)=1
  w(t+1)=w+dw(spikes)
continuous:
  trace_pre=sum(dirac(t-tspike_pre);tspike_pre)   <-- sum over presynaptic spikes
  trace_post=sum(dirac(t-tspike_post);tspike_post)   <-- sum over postsynaptic spikes
  dx/dt=-x+ax(x)*trace_pre
  dy/dt=-y+ay(y)*trace_post
  dw/dt=Ax(w).*x.*trace_post - Ay(w).*y.*trace_pre

spike tracking approach:
- monitor V.spikes(thresh) --> add .action to store spike times whenever upward threshold crossing occurs
- usage: 
	- assume only one type of event is tracked per population
	- access last event as tspike, tspike_pre, tspike_post
	- access nth previous spike time as tspike[n] (i.e., tspike=tspike[1])
  if(t-tspike_pre-axon_delay<=1/dt)(ds/dt=-s+a)(ds/dt=-s)


-----------------------------------------------------------------------

DDE: dx/dt=-x(t)+f(ax(t)-bx(t-tau))
==> XPP syntax: dx/dt=-x+f(a*x-b*delay(x,tau))
e.g.) ds/dt=-s+f(delay(V_pre,tau))
alternative syntax: dx/dt=-x+f(a*x-b*x(t-tau))   <-- parse: look for var(t-*)
http://www.math.pitt.edu/~bard/bardware/tut/newstyle.html#standard

DDE approach:
- if state var appears as X(t[-+]tau) in any equation, store every time point for X in X_delay including tspan(1)+[-tau 0] := X(0)
- replace X(t[-+]tau) by X_delay(n-D,:) where D=floor(tau/dt)


for each X with delay index:
 store d for each delay index into X
 find max across d's for a given X
 calc n for each d for a given X
 do substitutions for X delays in all ODEs
initialize X_d
add update for X_d



-----------------------------------------------------------------------

dev:
Windows patch
DynaSim GUI



Paid Boston parking Ticket #s:
722191853
724178092
698359863
Cambridge parking tickets:
287826350

card:
4291362222507042
12/19
122

wifi:
Olympus / 5HT2ALSD

--------------------------------------------------------





[tspike] = buffer x cell


user usage:
master:
dV/dt=@current; V(0)=-65; monitor V.spikes(thresh,buffer_size)
mechanism:
f = @(t) 1*(exp(-t/tauD)-exp(-t/tauR));
Isyn(V) = gsyn.*(netcon*sum(f(t-tspike_pre))).*(V-Esyn);

-----------
solve_file
-----------
initialize:
NAMESPACE_tspike = -inf(buffer_size,npop)
NAMESPACE_buffer_index = ones(1,npop)

update conditional actions:
if(any(spiked))(
	NAMESPACE_spikes(n,spiked)=1; 
	NAMESPACE_tspike(NAMESPACE_buffer_index,spiked)=t; 
	NAMESPACE_buffer_index(spiked)=mod(-1+(NAMESPACE_buffer_index(spiked)+1),buffer_size)+1
	       )

for i=find(spiked), tspike(buffer_index(i),i)=t; buffer_index(i)=mod(-1+(buffer_index(i)+1),buffer_size)+1; end


todo:
- assign namespace to tspike similar to state vars with _pre and _post (edit PropagateNamespaces)
- edit monitor code in WriteDynasimSolver
- test LIF network
- attempt STDP


dV/dt=(E-V+R*I+@isyn)/tau; tau=10; R=10; E=-70; I=1.55; thresh=-55; reset=-75; monitor V.spikes(thresh)


then: Windows patch

--------------
BUG:
f(t-u) will not substitute properly into f(t), only into f(x).  f(t)->f(t-u) = f((t-u)-t)

